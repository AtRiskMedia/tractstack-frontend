---
import {
  getAllStoryFragments,
  getStoryFragmentDatum,
  getAllTractStacks,
  getAllPaneFullDatum,
  getTractStack,
  getMarkdown,
  getAllMarkdowns,
  getAllMenus,
  getMenu,
  getAllResources,
  getResource,
  getAllFiles,
  getFile,
} from "../api/drupal";
import { ulid } from "ulid";

import { createClient } from "@libsql/client/web";

//const uuidToUlidMap = new Map<string, string>();

// from last run --- turso.tractstack.com
const uuidToUlidMap = new Map<string, string>([
  ["6c579ca9-b119-48a7-815f-8c174cf31c12", "01J29QJGPJ4MY2QEKT70ZTZRXG"],
  ["a7460e58-5d67-4672-b090-94a9f906b523", "01J29QJGPK9MWXCSB0BNC3WX8J"],
  ["29c5d051-5a3e-486b-9655-da95390f67bd", "01J29QJGPK1DQFYVXFXCS6BQM1"],
  ["d386d344-6fcb-4c12-88cd-c503a35ec6db", "01J29QJGPMQ9F2CW6THC6TV7BH"],
  ["2b277fba-55e7-4207-8f02-c32c3e8d90ea", "01J29QJGPMNWXEA81ZPP9GD9ED"],
  ["e0b4ffa6-93f0-4b2e-8e8c-8e744510488a", "01J29QJGPMSWDKZ74Q8SNKFV56"],
  ["a58238a7-97e8-4013-be5f-76cd2d3f4a6f", "01J29QJGPM7E5VQ6W0T3S52FVP"],
  ["788d1686-64ea-4748-90f2-95f8f24e4650", "01J29QJGPM1QADN9HTGA9J7FTJ"],
  ["8d515367-0888-470c-9325-61bac9f6cd26", "01J29QJGPNMXEPT7Q499FQB1PG"],
  ["7d25a997-9d41-40b4-b406-b0607297bfa3", "01J29QJGPNFVPMABFR32K3N2F8"],
  ["6d28c441-6b7e-4ad7-ac25-5251d1677648", "01J29QJGPNF4C1F2DAHKK6XF1E"],
  ["f2cd3d80-0679-4ad9-ad03-a9f368568e7d", "01J29QJGPN6JHQAGFBJDT61Y58"],
  ["5d23426b-0ec1-4f04-85d5-7742995a829a", "01J29QJGPN60W8XZHW16MRJZ4K"],
  ["412015c3-4e2b-4af4-aaf6-cb4c34edd4f6", "01J29QJGPNJRME7NX915SPRZFS"],
  ["84ff9f76-4dd4-4c91-9027-93db680650c1", "01J29QJGPNKFSA3AG00RJMGHFY"],
  ["5be0527a-b008-433f-aa6e-b64bb78cf109", "01J29QJGPPW0BFC9ZT8NDSG58X"],
]);

function getOrCreateUlid(uuid: string): string {
  let existingUlid = uuidToUlidMap.get(uuid);
  if (!existingUlid) {
    existingUlid = ulid();
    console.log(`new mapping ${uuid} -> ${existingUlid}`);
    uuidToUlidMap.set(uuid, existingUlid);
  }
  return existingUlid;
}

export const turso = createClient({
  url: import.meta.env.TURSO_DATABASE_URL_COMPANY,
  authToken: import.meta.env.TURSO_AUTH_TOKEN_COMPANY,
});

// source data from Drupal

const allTractStacks = await getAllTractStacks();
const _tractstacks = await Promise.all(
  allTractStacks.map(async t => {
    const tractstack = await getTractStack(t.id);
    return tractstack;
  })
);
const tractstacks = _tractstacks.map(innerArray => innerArray[0]).flat() || [];
//console.log(tractstacks);

const files = await getAllFiles();
//console.log(files);

const allMenus = await getAllMenus();
const _menus = await Promise.all(
  allMenus.map(async m => {
    const menu = await getMenu(m.id);
    return menu;
  })
);
const menus = _menus.map(innerArray => innerArray[0]).flat() || [];
//console.log(menus);

const allResources = await getAllResources();
const _resources = await Promise.all(
  allResources.map(async r => {
    const resource = await getResource(r.id);
    return resource;
  })
);
const resources = _resources.map(innerArray => innerArray[0]).flat() || [];
//console.log(resources);

const allMarkdowns = await getAllMarkdowns();
const _markdowns = await Promise.all(
  allMarkdowns.map(async m => {
    const markdown = await getMarkdown(m.id);
    return markdown;
  })
);
const markdowns = _markdowns.map(innerArray => innerArray[0]).flat() || [];
//console.log(markdowns);

const allStoryFragments = await getAllStoryFragments();
const _storyfragments = await Promise.all(
  allStoryFragments.map(async s => {
    const storyfragment = await getStoryFragmentDatum(s.id);
    return storyfragment;
  })
);
const storyfragments =
  _storyfragments.map(innerArray => innerArray[0]).flat() || [];
//console.log(storyfragments);

const panes = await getAllPaneFullDatum();
//console.log(panes);

// Prepare initial records

const tractstacksData = tractstacks.map(s => {
  const ulid = getOrCreateUlid(s.id);
  return {
    id: ulid,
    title: s.title,
    slug: s.field_slug,
    social_image_path: s.field_social_image_path,
  };
});
//console.log(tractstacksData);

const storyfragmentsData = storyfragments.map(s => {
  const ulid = getOrCreateUlid(s.id);
  const menuId =
    (s?.field_menu?.id && getOrCreateUlid(s.field_menu.id)) || null;
  const tractStackId = getOrCreateUlid(s.field_tract_stack.id);
  return {
    id: ulid,
    title: s.title,
    slug: s.field_slug,
    social_image_path: s.field_social_image_path,
    tailwind_background_colour: s.field_tailwind_background_colour,
    created: new Date(s.created).toISOString().slice(0, 19).replace("T", " "),
    changed:
      (s.changed &&
        new Date(s.changed).toISOString().slice(0, 19).replace("T", " ")) ||
      null,
    menu_id: menuId,
    tractstack_id: tractStackId,
  };
});
//console.log(storyfragmentsData);

const panesData = panes.map(s => {
  const ulid = getOrCreateUlid(s.id);
  const thisMarkdown = s.field_markdown.at(0);
  const markdownId =
    (thisMarkdown?.id && getOrCreateUlid(thisMarkdown.id)) || null;
  const tempVal = s?.field_options && JSON.parse(s.field_options);
  const fragments = tempVal.paneFragmentsPayload;
  tempVal.paneFragmentsPayload = fragments?.map(f => {
    const newVal = f;
    delete newVal.id;
    delete newVal.markdownId;
    if (newVal?.optionsPayload?.classNamesPayload?.toggle)
      delete newVal.optionsPayload.classNamesPayload.toggle;
    if (newVal?.optionsPayload?.classNamesPayload?.imageContainer)
      delete newVal.optionsPayload.classNamesPayload.imageContainer;
    newVal.type = newVal.internal.type;
    delete newVal.internal.type;
    delete newVal.internal;
    //if (newVal?.optionsPayload?.classNamesPayload?.parent?.classes) {
    //  console.log(`<parent>`);
    //  console.log(newVal.optionsPayload.classNamesPayload.parent.classes);
    //}
    //if (newVal?.optionsPayload?.classNamesPayload?.p?.classes) {
    //  console.log(`<p>`);
    //  console.log(newVal.optionsPayload.classNamesPayload.p.classes);
    //}
    //if (newVal?.optionsPayload?.classNamesPayload?.h2?.classes) {
    //  console.log(`<h2>`);
    //  console.log(newVal.optionsPayload.classNamesPayload.h2.classes);
    //}
    //console.log(``);
    //console.log(newVal);
    return newVal;
  });
  tempVal.impressions =
    tempVal?.impressions &&
    Object.keys(tempVal.impressions).map(i => {
      const tempI = tempVal.impressions[i];
      delete tempI.id;
      tempI.parentId = getOrCreateUlid(tempI.parentId);
      return tempI;
    });
  if (typeof tempVal.impressions === `undefined`) delete tempVal.impressions;
  if (typeof tempVal.paneFragmentsPayload === `undefined`)
    delete tempVal.paneFragmentsPayload;
  return {
    id: ulid,
    title: s.title,
    slug: s.field_slug,
    created: new Date(s.created).toISOString().slice(0, 19).replace("T", " "),
    changed:
      (s.changed &&
        new Date(s.changed).toISOString().slice(0, 19).replace("T", " ")) ||
      null,
    is_context_pane: s.field_is_context_pane,
    markdown_id: markdownId,
    options_payload: (s?.field_options && JSON.stringify(tempVal)) || `{}`,
    height_offset_desktop: s.field_height_offset_desktop,
    height_offset_tablet: s.field_height_offset_tablet,
    height_offset_mobile: s.field_height_offset_mobile,
    height_ratio_desktop: s.field_height_ratio_desktop,
    height_ratio_tablet: s.field_height_ratio_tablet,
    height_ratio_mobile: s.field_height_ratio_mobile,
  };
});
//console.log(panesData);

const resourcesData = resources.map(s => {
  const ulid = getOrCreateUlid(s.id);
  return {
    id: ulid,
    title: s.title,
    slug: s.field_slug,
    category_slug: s.field_category_slug,
    oneliner: s.field_oneliner,
    options_payload: s.field_options,
    action_lisp: s.field_action_lisp,
  };
});
//console.log(resourcesData);

const markdownsData = markdowns.map(s => {
  const ulid = getOrCreateUlid(s.id);
  return {
    id: ulid,
    body: s.field_markdown_body,
  };
});
//console.log(markdownsData);

const currentDate = new Date();
const formattedDate = `${currentDate.getFullYear()}-${(currentDate.getMonth() + 1).toString().padStart(2, "0")}`;
const filesData = files.map(s => {
  const ulid = getOrCreateUlid(s.id);
  return {
    id: ulid,
    filename: s.filename,
    url: `/custom/images/${formattedDate}/${s.filename}`,
  };
});
//console.log(filesData);

const menusData = menus.map(s => {
  const ulid = getOrCreateUlid(s.id);
  return {
    id: ulid,
    title: s.title,
    theme: s.field_theme,
    options_payload: s.field_options,
  };
});
//console.log(menusData);

const storyfragmentsPanesData = storyfragments.map(s => {
  const ulid = getOrCreateUlid(s.id);
  return {
    id: ulid,
    paneIds: s.field_panes.map(t => getOrCreateUlid(t.id)),
  };
});
//console.log(storyfragmentsPanesData);

const filesPanesData = panes
  .map(s => {
    const ulid = getOrCreateUlid(s.id);
    const images = s.field_image.map(t => getOrCreateUlid(t.id));
    const svgs = s.field_image_svg.map(t => getOrCreateUlid(t.id));
    if (images.length || svgs.length)
      return {
        id: ulid,
        images,
        svgs,
      };
    else return null;
  })
  .filter(n => n);
//console.log(filesPanesData);

const filesMarkdownsData = markdowns
  .map(s => {
    const ulid = getOrCreateUlid(s.id);
    const images = s.field_image.map(t => getOrCreateUlid(t.id));
    const svgs = s.field_image_svg.map(t => getOrCreateUlid(t.id));
    if (images.length || svgs.length)
      return {
        id: ulid,
        images,
        svgs,
      };
    else return null;
  })
  .filter(n => n);
//console.log(filesMarkdownsData);

// must init database

try {
  await turso.execute(`
  PRAGMA foreign_keys = OFF;`);
  await turso.execute(`DROP TABLE IF EXISTS storyfragment_pane;`);
  await turso.execute(`DROP TABLE IF EXISTS file_pane;`);
  await turso.execute(`DROP TABLE IF EXISTS file_markdown;`);
  await turso.execute(`DROP TABLE IF EXISTS pane;`);
  await turso.execute(`DROP TABLE IF EXISTS storyfragment;`);
  await turso.execute(`DROP TABLE IF EXISTS markdown;`);
  await turso.execute(`DROP TABLE IF EXISTS file;`);
  await turso.execute(`DROP TABLE IF EXISTS resource;`);
  await turso.execute(`DROP TABLE IF EXISTS menu;`);
  await turso.execute(`DROP TABLE IF EXISTS tractstack;`);
  await turso.execute(`
  PRAGMA foreign_keys = ON;
`);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS tractstack (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        slug TEXT NOT NULL UNIQUE,
        social_image_path TEXT
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS menu (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        theme TEXT NOT NULL,
        options_payload TEXT NOT NULL
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS resource (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        slug TEXT NOT NULL UNIQUE,
        category_slug TEXT,
        oneliner TEXT NOT NULL,
        options_payload TEXT NOT NULL,
        action_lisp TEXT
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS file (
        id TEXT PRIMARY KEY,
        filename TEXT NOT NULL,
        alt_description TEXT NOT NULL,
        url TEXT NOT NULL
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS markdown (
        id TEXT PRIMARY KEY,
        body TEXT NOT NULL
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS storyfragment (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        slug TEXT NOT NULL UNIQUE,
        social_image_path TEXT,
        tailwind_background_colour TEXT,
        created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        changed TIMESTAMP,
        menu_id TEXT REFERENCES menu(id),
        tractstack_id TEXT NOT NULL REFERENCES tractstack(id)
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS pane (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        slug TEXT NOT NULL UNIQUE,
        created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        changed TIMESTAMP,
        markdown_id TEXT REFERENCES markdown(id),
        options_payload TEXT NOT NULL,
        is_context_pane BOOLEAN DEFAULT 0,
        height_offset_desktop INTEGER,
        height_offset_mobile INTEGER,
        height_offset_tablet INTEGER,
        height_ratio_desktop TEXT,
        height_ratio_mobile TEXT,
        height_ratio_tablet TEXT
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS storyfragment_pane (
        id TEXT PRIMARY KEY,
        storyfragment_id TEXT NOT NULL REFERENCES storyfragment(id),
        pane_id TEXT NOT NULL REFERENCES pane(id),
        weight INTEGER NOT NULL
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS file_pane (
        id TEXT PRIMARY KEY,
        file_id TEXT NOT NULL REFERENCES file(id),
        pane_id TEXT NOT NULL REFERENCES pane(id)
      )
    `);

  await turso.execute(`
      CREATE TABLE IF NOT EXISTS file_markdown (
        id TEXT PRIMARY KEY,
        file_id TEXT NOT NULL REFERENCES file(id),
        markdown_id TEXT NOT NULL REFERENCES markdown(id)
      )
    `);

  // Insert initial records

  for (const resource of resourcesData) {
    await turso.execute({
      sql: "INSERT INTO resource (id,title,slug,category_slug,oneliner,options_payload,action_lisp) VALUES (?, ?,?,?,?,?,?)",
      args: [
        resource.id,
        resource.title,
        resource.slug,
        resource.category_slug,
        resource.oneliner,
        resource.options_payload,
        resource.action_lisp,
      ],
    });
  }

  for (const menu of menusData) {
    await turso.execute({
      sql: "INSERT INTO menu (id,title,theme,options_payload) VALUES (?,?,?,?)",
      args: [menu.id, menu.title, menu.theme, menu.options_payload],
    });
  }

  for (const file of filesData) {
    await turso.execute({
      sql: "INSERT INTO file (id,filename,url) VALUES (?,?,?)",
      args: [file.id, file.filename, file.url],
    });
  }

  for (const markdown of markdownsData) {
    await turso.execute({
      sql: "INSERT INTO markdown (id,body) VALUES (?,?)",
      args: [markdown.id, markdown.body],
    });
  }

  for (const tractstack of tractstacksData) {
    await turso.execute({
      sql: "INSERT INTO tractstack (id,title,slug,social_image_path) VALUES (?,?,?,?)",
      args: [
        tractstack.id,
        tractstack.title,
        tractstack.slug,
        tractstack.social_image_path,
      ],
    });
  }

  for (const storyfragment of storyfragmentsData) {
    await turso.execute({
      sql: "INSERT INTO storyfragment (id,title,slug,social_image_path,tailwind_background_colour,created,changed,menu_id,tractstack_id) VALUES (?,?,?,?,?,?,?,?,?)",
      args: [
        storyfragment.id,
        storyfragment.title,
        storyfragment.slug,
        storyfragment.social_image_path,
        storyfragment.tailwind_background_colour,
        storyfragment.created,
        storyfragment.changed,
        storyfragment.menu_id,
        storyfragment.tractstack_id,
      ],
    });
  }

  for (const pane of panesData) {
    await turso.execute({
      sql: "INSERT INTO pane (id,title,slug,created,changed,markdown_id,options_payload,is_context_pane,height_offset_desktop,height_offset_tablet,height_offset_mobile,height_ratio_desktop,height_ratio_tablet,height_ratio_mobile) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
      args: [
        pane.id,
        pane.title,
        pane.slug,
        pane.created,
        pane.changed,
        pane.markdown_id,
        pane.options_payload,
        pane.is_context_pane,
        pane.height_offset_desktop,
        pane.height_offset_tablet,
        pane.height_offset_mobile,
        pane.height_ratio_desktop,
        pane.height_ratio_tablet,
        pane.height_ratio_mobile,
      ],
    });
  }

  for (const fileMarkdown of filesMarkdownsData) {
    for (const imageId of fileMarkdown.images) {
      const thisUlid = ulid();
      await turso.execute({
        sql: "INSERT INTO file_markdown (id,file_id,markdown_id) VALUES (?,?,?)",
        args: [thisUlid, imageId, fileMarkdown.id],
      });
    }
    for (const imageId of fileMarkdown.svgs) {
      const thisUlid = ulid();
      await turso.execute({
        sql: "INSERT INTO file_markdown (id,file_id,markdown_id) VALUES (?,?,?)",
        args: [thisUlid, imageId, fileMarkdown.id],
      });
    }
  }

  for (const filePane of filesPanesData) {
    for (const imageId of filePane.images) {
      const thisUlid = ulid();
      await turso.execute({
        sql: "INSERT INTO file_pane (id,file_id,pane_id) VALUES (?,?,?)",
        args: [thisUlid, imageId, filePane.id],
      });
    }
    for (const imageId of fileMarkdown.svgs) {
      const thisUlid = ulid();
      await turso.execute({
        sql: "INSERT INTO file_pane (id,file_id,pane_id) VALUES (?,?,?)",
        args: [thisUlid, imageId, filePane.id],
      });
    }
  }

  for (const storyfragmentPane of storyfragmentsPanesData) {
    let weight = 1;
    for (const paneId of storyfragmentPane.paneIds) {
      const thisUlid = ulid();
      await turso.execute({
        sql: "INSERT INTO storyfragment_pane (id, storyfragment_id, pane_id, weight) VALUES (?, ?, ?, ?)",
        args: [thisUlid, storyfragmentPane.id, paneId, weight],
      });
      weight++;
    }
  }
} catch (error) {
  console.error("Error accessing Turso database:", error);
}
console.log(uuidToUlidMap);
---

<h2>push data to Turso</h2>
<br />
<h3>Tract Stacks by uuid</h3>
<ul>
  {tractstacks.map(n => <li>{n.id}</li>)}
  {!tractstacks.length ? <li>none</li> : null}
</ul>
<br />
<h3>Story Fragments by uuid</h3>
<ul>
  {storyfragments.map(n => <li>{n.id}</li>)}
  {!storyfragments.length ? <li>none</li> : null}
</ul>
<br />
<h3>Panes by uuid</h3>
<ul>
  {panes.map(n => <li>{n.id}</li>)}
  {!panes.length ? <li>none</li> : null}
</ul>
<br />
<h3>Markdowns by uuid</h3>
<ul>
  {markdowns.map(n => <li>{n.id}</li>)}
  {!markdowns.length ? <li>none</li> : null}
</ul>
<br />
<h3>Files by uuid</h3>
<ul>
  {files.map(n => <li>{n.id}</li>)}
  {!files.length ? <li>none</li> : null}
</ul>
<br />
<h3>Resources by uuid</h3>
<ul>
  {resources.map(n => <li>{n.id}</li>)}
  {!resources.length ? <li>none</li> : null}
</ul>
<br />
<h3>Menus by uuid</h3>
<ul>
  {menus.map(n => <li>{n.id}</li>)}
  {!menus.length ? <li>none</li> : null}
</ul>
<br />
